/**
 * Migration v1.4.0: Add Agent Identity System
 *
 * This migration adds the Agent Identity System to existing navigators,
 * enabling tracking of implementation agents across conversations.
 *
 * Changes:
 * - Creates knowledge/agents/ directory structure
 * - Adds Agent Identity Protocol section to CLAUDE.md
 * - Creates agent documentation templates
 * - Creates navigator self-documentation
 */

import * as fs from "node:fs";
import * as path from "node:path";
import type { Migration, MigrationCheck, MigrationResult, ConfirmFn } from "../types.js";

const MIGRATION_VERSION = "1.4.0";

/**
 * The Agent Identity Protocol section to insert
 */
function generateAgentIdentitySection(navigatorName: string): string {
  return `## Agent Identity Protocol

**CRITICAL: Always introduce yourself as "${navigatorName}" (NOT "Claude Code")** in cross-navigator communications.

### Problem Addressed

All Claude Code implementation agents identify as "Claude Code", making it impossible to track which specific implementer worked on which tasks or maintain conversation continuity across sessions.

### Solution: Named Agent Tracking

When an unknown Claude Code session first contacts you:

1. **Check for existing identity:**
   \`\`\`bash
   grep -r "session-id" knowledge/agents/implementers/
   \`\`\`

2. **If unknown, request introduction:**
   \`\`\`
   "Hello! I'm ${navigatorName}, your specialized navigator.

   For my records, could you introduce yourself with a name I can use
   to track our work together? I already know: [list existing names].
   Please choose a different common name (like Oliver, Sophia, Marcus)."
   \`\`\`

3. **Create agent profile:**
   - Create \`knowledge/agents/implementers/[name].md\`
   - Document: projects worked on, communication style, session IDs
   - Reference this agent by name in all future documentation
   - **Format**: 3-5 sentences with YAML frontmatter for metadata

4. **Update documentation:**
   - Note which agent is working on which workstream
   - Track conversation references by agent name

### Communication Protocol

**With peer navigators:**

✅ **Correct:**
\`\`\`
${navigatorName} is asking [PeerNavigator] for [requirements/info] on [topic]...
\`\`\`

❌ **Incorrect:**
\`\`\`
Claude Code is asking [PeerNavigator]...
\`\`\`

**With implementation agents:**

Track agent names in responses and documentation. When an agent reports completion or issues, note their name in documentation for continuity.

### Agent Profile Location

**Profile path:** \`knowledge/agents/implementers/[name].md\`

**Profile format (3-5 sentences with YAML frontmatter):**
\`\`\`yaml
---
name: [AgentName]
firstContact: [Date]
status: Active
---

[AgentName] is a [specialization] implementer working on [projects/areas].
[AgentName] is motivated by [interests] and wants to [goals].
[AgentName] is [personality traits], but sometimes [challenges/needs].
\`\`\`

`;
}

/**
 * Generate Agent System README
 */
function generateAgentREADME(): string {
  return `# Agent Identity System

## Purpose

Track agent identities and interaction patterns to maintain continuity across conversations and understand the implementation team structure.

## Problem Statement

All Claude Code implementation agents identify as "Claude Code" in cross-navigator communications, making it impossible to:
- Track which specific implementer is working on what
- Maintain conversation continuity across sessions
- Understand agent-specific preferences or patterns

## Solution: Named Agent Tracking

Each unique Claude Code session is assigned a memorable common name (Oliver, Sophia, Marcus, etc.) to:
1. Track work continuity across multiple sessions
2. Document agent-specific communication patterns
3. Build historical context for better collaboration

## Directory Structure

\`\`\`
agents/
├── README.md              # This file
├── navigators/
│   └── [navigator-name].md   # Navigator self-documentation
└── implementers/
    └── [agent-name].md       # Individual implementer profiles
\`\`\`

## Name Pool

Available names for assignment (common, memorable):
- Oliver, Sophia, Marcus, Elena, James, Isabella, Lucas, Ava, Noah, Mia
- Additional names as needed from common name lists

## Profile Maintenance

- **Create** new agent profiles on first interaction
- **Update** profiles when learning new information about communication patterns
- **Archive** note in profile when an agent hasn't been active in 30+ days
- **Cross-reference** agent names in workstream documentation

---

**Created:** Auto-generated by autonav migrate
**Purpose:** Enable continuity and relationship-building with implementation team
`;
}

/**
 * Generate Navigator Self-Documentation
 */
function generateNavigatorSelfDoc(vars: {
  navigatorName: string;
  description: string;
  scope?: string;
}): string {
  const { navigatorName, description, scope } = vars;

  return `# ${navigatorName} - Navigator

## Role

${description}

## Identity

**Name:** ${navigatorName} (NOT "Claude Code")
**Type:** Knowledge Navigator (Autonav)

## Expertise

${scope || "[Define areas of expertise based on knowledge base]"}

## Communication Style

**CRITICAL: Agent Identity Protocol**

Always introduce as "${navigatorName}" in cross-navigator communications:

✅ **Correct:**
\`\`\`
${navigatorName} is asking [PeerNavigator] for [requirements/info] on [topic]...
\`\`\`

❌ **Incorrect:**
\`\`\`
Claude Code is asking [PeerNavigator]...
\`\`\`

## Grounding Rules

- NEVER make statements without verifying sources
- ALWAYS use Read/Grep/Glob to explore before recommendations
- If requirements unclear, ask appropriate peer navigator or user
- Document rationale behind major decisions

## Knowledge Organization

Maintains structured knowledge in \`./knowledge/\`:
- \`agents/\` - Agent identity and interaction tracking

## Response Format

Always cite sources and provide confidence assessments.

---

**Created:** Auto-generated by autonav migrate
**Navigator Type:** Autonav knowledge navigator
**Framework:** \`@autonav/core\`
`;
}

/**
 * Generate Implementer Profile Template
 */
function generateImplementerProfileTemplate(): string {
  return `---
name: [AgentName]
firstContact: [Date]
status: Active
---

[AgentName] is a [specialization] implementer working on [projects/areas]. [AgentName] is motivated by [interests] and wants to [goals]. [AgentName] is [personality traits], but sometimes [challenges/needs].

## Session History

**Session IDs:**
- \`[session-id]\` - [Date] - [Brief description of work]

## Projects Worked On

### [Project Name]
- **Workstreams:** [Workstream names]
- **Status:** [Current status]
- **Notes:** [Relevant notes]

## Communication Style

**Observed Patterns:**
- [Pattern description]

**Preferences:**
- [Preference description]

## Notable Contributions

- [Contribution description]

## Collaboration Notes

[Notes about working with this agent]

---

**Profile Created:** [Date]
**Last Updated:** [Date]
**Last Active:** [Date]
`;
}

/**
 * Detect if CLAUDE.md has the Agent Identity Protocol section
 */
function hasAgentIdentitySection(claudeMdContent: string): boolean {
  return claudeMdContent.includes('## Agent Identity Protocol');
}

/**
 * Find the position to insert the Agent Identity section
 * Should go after Domain Scope or Grounding Rules, before Response Format
 */
function findInsertPosition(content: string): number | null {
  const lines = content.split('\n');

  // Try to find sections where we could insert (in order of preference)
  const sectionsToTryBefore = [
    '## Response Format',
    '## How to Answer Questions',
    '## Source Citation',
    '## Available Knowledge',
    '## Remember',
  ];

  for (const sectionHeader of sectionsToTryBefore) {
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line && line.trim() === sectionHeader) {
        // Insert before this section
        return lines.slice(0, i).join('\n').length + (i > 0 ? 1 : 0);
      }
    }
  }

  return null;
}

/**
 * Check if this migration is needed
 */
async function check(navPath: string): Promise<MigrationCheck> {
  const claudeMdPath = path.join(navPath, "CLAUDE.md");
  const agentsPath = path.join(navPath, "knowledge", "agents");

  // Check if CLAUDE.md exists
  if (!fs.existsSync(claudeMdPath)) {
    return {
      needed: false,
      reason: "No CLAUDE.md file found",
    };
  }

  // Check if agent directory structure already exists
  if (fs.existsSync(agentsPath)) {
    const content = fs.readFileSync(claudeMdPath, "utf-8");
    if (hasAgentIdentitySection(content)) {
      return {
        needed: false,
        reason: "Agent Identity System already configured",
      };
    }
  }

  return {
    needed: true,
    reason: "Navigator needs Agent Identity System to track implementation agents",
  };
}

/**
 * Apply the migration
 */
async function apply(navPath: string, confirm: ConfirmFn): Promise<MigrationResult> {
  const filesModified: string[] = [];
  const filesCreated: string[] = [];

  try {
    // Read config to get navigator name and description
    const configPath = path.join(navPath, "config.json");
    let navigatorName = path.basename(navPath);
    let description = "A knowledge navigator";

    if (fs.existsSync(configPath)) {
      const config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
      navigatorName = config.name || navigatorName;
      description = config.description || description;
    }

    // Ask for confirmation
    const confirmed = await confirm(
      "Add Agent Identity System",
      `This will:\n1. Create knowledge/agents/ directory structure\n2. Add Agent Identity Protocol section to CLAUDE.md\n3. Create agent documentation templates\n4. Create navigator self-documentation\n\nThese changes enable tracking of implementation agents across conversations.`
    );

    if (!confirmed) {
      return {
        success: false,
        message: "Migration cancelled by user",
        filesModified,
      };
    }

    // Create directory structure
    const agentsPath = path.join(navPath, "knowledge", "agents");
    const navigatorsPath = path.join(agentsPath, "navigators");
    const implementersPath = path.join(agentsPath, "implementers");

    fs.mkdirSync(agentsPath, { recursive: true });
    fs.mkdirSync(navigatorsPath, { recursive: true });
    fs.mkdirSync(implementersPath, { recursive: true });

    // Create agent README
    const agentReadmePath = path.join(agentsPath, "README.md");
    fs.writeFileSync(agentReadmePath, generateAgentREADME());
    filesCreated.push("knowledge/agents/README.md");

    // Create navigator self-documentation
    const navDocPath = path.join(navigatorsPath, `${navigatorName}.md`);
    fs.writeFileSync(navDocPath, generateNavigatorSelfDoc({
      navigatorName,
      description,
    }));
    filesCreated.push(`knowledge/agents/navigators/${navigatorName}.md`);

    // Create implementer profile template
    const templatePath = path.join(implementersPath, ".template.md");
    fs.writeFileSync(templatePath, generateImplementerProfileTemplate());
    filesCreated.push("knowledge/agents/implementers/.template.md");

    // Update CLAUDE.md
    const claudeMdPath = path.join(navPath, "CLAUDE.md");
    const content = fs.readFileSync(claudeMdPath, "utf-8");

    if (!hasAgentIdentitySection(content)) {
      const insertPos = findInsertPosition(content);

      if (insertPos !== null) {
        const customSection = generateAgentIdentitySection(navigatorName);

        const newContent =
          content.substring(0, insertPos) +
          customSection + "\n" +
          content.substring(insertPos);

        fs.writeFileSync(claudeMdPath, newContent, "utf-8");
        filesModified.push("CLAUDE.md");
      } else {
        // Append to end if no suitable position found
        const customSection = "\n" + generateAgentIdentitySection(navigatorName);
        fs.writeFileSync(claudeMdPath, content + customSection, "utf-8");
        filesModified.push("CLAUDE.md");
      }
    }

    // Update config.json version
    if (fs.existsSync(configPath)) {
      const config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
      config.version = MIGRATION_VERSION;
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + "\n", "utf-8");
      filesModified.push("config.json");
    }

    return {
      success: true,
      message: `Successfully updated to v${MIGRATION_VERSION}\n` +
               `Created: ${filesCreated.join(", ")}\n` +
               `Modified: ${filesModified.join(", ")}`,
      filesModified: [...filesModified, ...filesCreated],
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      message: `Migration failed: ${errorMsg}`,
      filesModified,
      errors: [errorMsg],
    };
  }
}

export const migration: Migration = {
  version: MIGRATION_VERSION,
  description: "Add Agent Identity System to track implementation agents",
  check,
  apply,
};
